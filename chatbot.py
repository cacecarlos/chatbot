# -*- coding: utf-8 -*-
"""chatbot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EcRaV68wI31jB-BHeywXlEgVkSiKiD0Z
"""

# Instalación de las librerías necesarias (si no están instaladas aún)
!pip install chatterbot
!pip install chatterbot_corpus
!pip install requests

# Importación de las librerías necesarias
from chatterbot import ChatBot
from chatterbot.trainers import ListTrainer
import requests
import random
import json

# Función para obtener el precio de Bitcoin
def obtener_precio_bitcoin():
    try:
        url = "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd"
        response = requests.get(url)
        data = response.json()

        if 'bitcoin' in data:
            precio = data['bitcoin']['usd']
            return f"El precio actual del Bitcoin es ${precio} USD."
        else:
            return "Lo siento, no pude obtener el precio del Bitcoin en este momento."
    except Exception as e:
        return f"Ocurrió un error al intentar obtener el precio del Bitcoin: {str(e)}"

# Crear el chatbot con almacenamiento en base de datos SQL
chatbot = ChatBot(
    'MiBotNegocio',
    storage_adapter='chatterbot.storage.SQLStorageAdapter',
    logic_adapters=[
        'chatterbot.logic.BestMatch',
        'chatterbot.logic.MathematicalEvaluation',
        'chatterbot.logic.TimeLogicAdapter',
    ],
    database_uri='sqlite:///database.db',  # Base de datos SQLite para almacenamiento persistente
)

# Cargar datos de entrenamiento desde un archivo JSON
def cargar_datos_entrenamiento(archivo_json):
    with open(archivo_json, 'r', encoding='utf-8') as f:
        data = json.load(f)
    return [(entry['pregunta'], entry['respuesta']) for entry in data]

# Cargar los datos de entrenamiento
custom_training_data = cargar_datos_entrenamiento("training_data.json")

# Usamos ListTrainer para agregar las preguntas y respuestas personalizadas
list_trainer = ListTrainer(chatbot)
for pregunta, respuesta in custom_training_data:
    list_trainer.train([pregunta, respuesta])

# Función de respaldo para cuando el bot no entiende la pregunta
def respuesta_sin_sentido():
    respuestas_generales = [
        "Lo siento, no entendí eso. ¿Podrías reformularlo?",
        "No tengo suficiente información para responder eso. ¿Puedes preguntar de otra manera?",
        "Parece que no entiendo tu pregunta. ¿Podrías ser más específico?"
    ]
    return random.choice(respuestas_generales)

# Función para interactuar con el bot
def obtener_respuesta(pregunta):
    # Si la pregunta tiene relación con el precio de Bitcoin, usamos la función de obtener el precio
    if 'bitcoin' in pregunta.lower():
        return obtener_precio_bitcoin()

    # Si el bot no tiene respuesta, usar una respuesta predeterminada
    respuesta = chatbot.get_response(pregunta)

    if respuesta.confidence < 0.33:
        return respuesta_sin_sentido()  # Respuesta cuando la confianza es baja
    else:
        return respuesta

# Mensaje inicial
print("¡Hola! Soy tu asistente virtual. ¿Cómo puedo ayudarte hoy?")

# Interacción con el chatbot
while True:
    try:
        # Obtener la entrada del usuario
        usuario_input = input("Tú: ")

        if usuario_input.lower() == 'salir':
            print("Bot: ¡Hasta luego!")
            break

        # Obtener respuesta del bot
        respuesta = obtener_respuesta(usuario_input)

        print("Bot:", respuesta)

    except (KeyboardInterrupt, EOFError, SystemExit):
        break